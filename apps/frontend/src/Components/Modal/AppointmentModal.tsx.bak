// apps/frontend/src/Components/Modal/PremiumAppointmentModal.tsx
import React, { Suspense, useMemo, useCallback, useState, memo } from "react";
import {
  Modal,
  ModalOverlay,
  ModalContent,
  ModalCloseButton,
  ModalBody,
  ModalFooter,
  Box,
  HStack,
  VStack,
  Text,
  Badge,
  Tag,
  TagLabel,
  Avatar,
  Button,
  Tooltip,
  useClipboard,
  SimpleGrid,
  useColorModeValue,
  Icon,
  Skeleton,
  useDisclosure,
  Tabs,
  TabList,
  TabPanels,
  Tab,
  TabPanel,
  IconButton,
  Input,
  useToast,
  AlertDialog,
  AlertDialogBody,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogContent,
  AlertDialogOverlay,
} from "@chakra-ui/react";
import { FiCalendar, FiClock, FiClipboard, FiInfo, FiTrash2, FiEdit2 } from "react-icons/fi";
import { PhoneIcon } from "@chakra-ui/icons";
import { FaStar } from "react-icons/fa";
import AppointmentSlotEditorModal, { DateRange } from "../CustomTemplates/AppointmentSlotEditorModal";
import { useQueryClient } from "@tanstack/react-query";
import { useGetCollection } from "@/Hooks/Query/useGetCollection";
import { useUpdateItems } from "@/Hooks/Query/useUpdateItems";
import { Appointment, ContactAppointment, Provider } from "@/types";
import { useProviderSchedule } from "@/Hooks/Query/useProviderSchedule";
import { useProviderAppointments } from "@/Hooks/Query/useProviderAppointments";
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import timezone from 'dayjs/plugin/timezone';

dayjs.extend(utc);
dayjs.extend(timezone);
import { formatDateWS } from "@/Functions/FormatDateWS";
import { GrContact } from "react-icons/gr";
import { CiUser } from "react-icons/ci";
import { pickDisplaySlot } from "@/Functions/getLatestSelectedAppDate";

// ðŸš€ Chat: componente reutilizable (lazy) + icono
import ChatLauncher from "@/Components/Chat/ChatLauncher";
import { FaCommentSms } from "react-icons/fa6";
import { useModalIndex } from "../ModalStack/ModalStackContext";
import { formatAusPhoneNumber } from "@/Functions/formatAusPhoneNumber";
import { RiParentFill } from "react-icons/ri";
import { useSocket } from "@/Hooks/Query/useSocket";
import { useGoogleReviewRequests } from "@/Hooks/Query/useGoogleReviews";
import { format } from "date-fns";
import AvailabilityDates2, { SelectedDaysState, SelectedDatesValue } from "@/Components/CustomTemplates/AvailabilityDates2";
import { useAppointmentLabels } from "@/Hooks/useAppointmentLabels";
import AppointmentLabelManager from "@/Components/Appointments/AppointmentLabelManager";
import AppointmentLabelAssigner from "@/Components/Appointments/AppointmentLabelAssigner";
import LabelChip from "@/Components/Kanban/LabelChip";
import { Wrap, WrapItem } from "@chakra-ui/react";
import { SelectedAppointmentDates } from "../Appointment/SelectedAppointmentDates";

// â€” Lazy load del ProviderSummaryModal â€”
const ProviderSummaryModalLazy = React.lazy(
  () => import("@/Components/Provider/ProviderSummaryModal")
);
// â€” Lazy load self for tutor jump â€”
const AppointmentModalLazy = React.lazy(() => import("@/Components/Modal/AppointmentModal"));

// -----------------------------
// Tipos basados en tus esquemas Mongoose (actualizados)
// -----------------------------
export type TimeSlot = string;
export type WeekDay = string;

export interface Treatment {
  _id: string;
  org_id?: string;
  name: string;
  duration: number;
  icon: string;
  minIcon: string;
  color: string;
  category?: string;
  active?: boolean;
  createdAt?: string;
  updatedAt?: string;
}

export interface TimeBlock {
  _id?: string;
  org_id: string;
  blockNumber: number;
  label: TimeSlot;
  short?: string;
  from: string;
  to: string;
}

export interface SelectedDates {
  startDate: Date;
  endDate: Date;
  days: Array<{
    weekDay: WeekDay;
    timeBlocks: TimeBlock[];
    timeBlocksData?: TimeBlock[];
  }>;
}

export interface Priority {
  _id?: string;
  org_id?: string;
  id: number;
  description?: string;
  notes?: string;
  durationHours?: number;
  name: string;
  color: string;
}

// -----------------------------
// Tipado adicional para slots y logs de contacto (reduce uso de any)
// -----------------------------
export interface AppointmentSlotConfirmation {
  askMessageSid?: string;
  sentAt?: string | Date;
  decidedAt?: string | Date;
  lateResponse?: boolean;
  status?: string;
}
export interface AppointmentSlotProposed {
  startDate?: string | Date;
  endDate?: string | Date;
  createdAt?: string | Date;
  reason?: string;
}
export interface AppointmentSlot {
  _id?: string;
  startDate?: string | Date;
  endDate?: string | Date;
  proposed?: AppointmentSlotProposed;
  confirmation?: AppointmentSlotConfirmation;
  status?: string;
  rescheduleRequested?: boolean;
  treatment?: Treatment;
  priority?: Priority;
  providers?: Provider[];
  updatedAt?: string | Date;
}

export interface ContactAppointmentSlim extends Omit<ContactAppointment, 'appointment'> {
  selectedAppDate?: string | AppointmentSlot; // puede venir poblado con el objeto del slot
  askMessageSid?: string;
  proposedStartDate?: string | Date;
  proposedEndDate?: string | Date;
  appointment?: {
    selectedAppDates?: AppointmentSlot[]; // lista recortada (solo slot relacionado)
  };
}

export interface ContactLog {
  _id?: string;
  appointment: string;
  contactedAt: Date;
  contactedBy: string;
  method: "Phone" | "Email" | "SMS" | "WhatsApp";
  status: "Pending" | "Contacted" | "Failed" | "No Contacted";
  notes?: string;
  org_id: string;
}
// removed unused Contacted type

// -----------------------------
// Helpers visuales
// -----------------------------
const fmtDateTime = (d?: Date | string | number) =>
  d
    ? new Date(d).toLocaleString("en-AU", {
      timeZone: "Australia/Sydney",
      day: "2-digit",
      month: "short",
      year: "numeric",
      hour: "numeric",
      minute: "2-digit",
      hour12: true,
    })
    : "â€”";

function contrastText(hex?: string): string {
  if (!hex) return "white";
  const h = hex.replace("#", "");
  const bigint = parseInt(
    h.length === 3 ? h.split("").map((c) => c + c).join("") : h,
    16
  );
  const r = (bigint >> 16) & 255,
    g = (bigint >> 8) & 255,
    b = bigint & 255;
  const yiq = (r * 299 + g * 587 + b * 114) / 1000;
  return yiq >= 128 ? "black" : "white";
}

function enrichAvatarColor(color?: string): { bg: string; color: string; borderColor: string } {
  if (!color) return { bg: "gray.500", color: "white", borderColor: "gray.700" };

  // Si es un color de Chakra (e.g., "blue", "red")
  if (!color.startsWith('#') && !color.includes('.')) {
    return {
      bg: `${color}.500`,
      color: "white",
      borderColor: `${color}.700`,
    };
  }

  // Si ya viene con nivel (e.g., "blue.500"), lo mantenemos
  if (color.includes(".")) {
    const [base] = color.split(".");
    return {
      bg: `${base}.500`,
      color: "white",
      borderColor: `${base}.700`,
    };
  }

  // Si es hex, calculamos contraste y aÃ±adimos borde oscuro
  const textColor = contrastText(color);
  return {
    bg: color,
    color: textColor,
    borderColor: textColor === "white" ? "blackAlpha.400" : "blackAlpha.600",
  };
}

// Normaliza status para comparaciones case-insensitive
const statusKey = (s?: string): string => String(s || '').trim().toLowerCase();

const capStatus = (s?: string): string => {
  const k = statusKey(s);
  if (!k) return 'Unknown';
  return k.replace(/^[a-z]/, c => c.toUpperCase());
};

// âœ¨ Optimized slot deduplication and sorting
const deduplicateAndSortSlots = (slots: AppointmentSlot[]): AppointmentSlot[] => {
  if (!slots?.length) return [];

  const updatedAtTs = (s: AppointmentSlot): number => {
    if (s?.updatedAt) {
      const t = new Date(s.updatedAt).getTime();
      return Number.isFinite(t) ? t : 0;
    }
    return 0;
  };

  // Sort by updatedAt (most recent first)
  const sorted = [...slots].sort((a, b) => updatedAtTs(b) - updatedAtTs(a));

  // Deduplicate by range
  const seen = new Set<string>();
  const deduped: AppointmentSlot[] = [];
  
  for (const s of sorted) {
    const hasTopDates = s?.startDate && s?.endDate;
    const key = hasTopDates
      ? `${new Date(s.startDate!).getTime()}|${new Date(s.endDate!).getTime()}`
      : `__unique__${String(s?._id ?? Math.random())}`;
    
    if (seen.has(key)) continue;
    seen.add(key);
    deduped.push(s);
  }

  return deduped;
};

// âœ¨ Centralized slot matching logic
const matchSlot = (
  log: ContactAppointmentSlim,
  slotList: AppointmentSlot[]
): AppointmentSlot | null => {
  if (!slotList?.length) return null;

  const rawSel = log?.selectedAppDate;
  
  // 1. Already populated object
  if (rawSel && typeof rawSel === 'object') {
    return rawSel as AppointmentSlot;
  }

  // 2. Match by ID
  const selId = typeof rawSel === 'string' ? rawSel : '';
  if (selId) {
    const match = slotList.find(s => String(s?._id) === selId);
    if (match) return match;
  }

  // 3. Match by askMessageSid
  const askSid = log?.askMessageSid ? String(log.askMessageSid) : "";
  if (askSid) {
    const match = slotList.find(s => String(s?.confirmation?.askMessageSid || "") === askSid);
    if (match) return match;
  }

  // 4. Match by dates
  if (log?.startDate && log?.endDate) {
    const st = new Date(log.startDate).getTime();
    const et = new Date(log.endDate).getTime();
    
    if (!Number.isNaN(st) && !Number.isNaN(et)) {
      const match = slotList.find(s => {
        const t1 = s?.startDate ? new Date(s.startDate).getTime() : NaN;
        const t2 = s?.endDate ? new Date(s.endDate).getTime() : NaN;
        const p1 = s?.proposed?.startDate ? new Date(s.proposed.startDate).getTime() : NaN;
        const p2 = s?.proposed?.endDate ? new Date(s.proposed.endDate).getTime() : NaN;
        return (t1 === st && t2 === et) || (p1 === st && p2 === et);
      });
      if (match) return match;
    }
  }

  return null;
};

// ============================================================================
// SUB-COMPONENTS (memoized for performance)
// ============================================================================
const SectionCard = memo<{
  title: React.ReactNode;
  right?: React.ReactNode;
  children?: React.ReactNode;
}>(({ title, right, children }) => {
  const bg = useColorModeValue("whiteAlpha.900", "whiteAlpha.50");
  const border = useColorModeValue("blackAlpha.100", "whiteAlpha.200");
  
  return (
    <Box
      bg={bg}
      border="1px solid"
      borderColor={border}
      rounded="2xl"
      p={4}
      boxShadow="xl"
      backdropFilter="auto"
      backdropBlur="6px"
    >
      <HStack justify="space-between" mb={3}>
        <HStack>{title}</HStack>
        {right}
      </HStack>
      {children}
    </Box>
  );
});
SectionCard.displayName = "SectionCard";

const LabeledRow = memo<{
  icon?: any;
  label: string;
  value?: React.ReactNode;
  copyable?: boolean;
}>(({ icon, label, value, copyable }) => {
  const isPrimitive = typeof value === "string" || typeof value === "number";
  const copyText = isPrimitive ? String(value) : "";
  const { onCopy } = useClipboard(copyText);
  const sub = useColorModeValue("gray.600", "gray.300");
  
  return (
    <HStack align="flex-start" spacing={3}>
      {icon && <Icon as={icon} boxSize={4} mt={1} opacity={0.9} />}
      <VStack align="start" spacing={0} flex={1}>
        <Text fontSize="xs" textTransform="uppercase" letterSpacing={0.4} color={sub}>
          {label}
        </Text>
        <HStack align="start">
          {isPrimitive ? (
            <Text as="span" fontWeight="semibold">{value ?? "â€”"}</Text>
          ) : (
            <Box as="span" fontWeight="semibold">{value ?? "â€”"}</Box>
          )}
          {copyable && copyText && (
            <Tooltip label="Copy" placement="top">
              <Box as="button" onClick={onCopy} aria-label={`Copy ${label}`}>
                <FiClipboard />
              </Box>
            </Tooltip>
          )}
        </HStack>
      </VStack>
    </HStack>
  );
});
LabeledRow.displayName = "LabeledRow";

const PriorityTag = memo<{ priority?: Priority | null }>(({ priority }) => (
  <Tag
    size="sm"
    rounded="full"
    px={3}
    py={1}
    bg={priority?.color ?? "pink.400"}
    color={contrastText(priority?.color)}
  >
    <TagLabel>{priority?.name ?? "No priority"}</TagLabel>
  </Tag>
));
PriorityTag.displayName = "PriorityTag";

// ============================================================================
// PROVIDER ROW WITH AVAILABILITY CHECKING (like CustomEntryForm)
// ============================================================================
const DEFAULT_TZ = 'Australia/Sydney';

// Helper to check if provider has time conflicts with existing appointments
function hasTimeConflict(
  slotStartDate: Date,
  slotEndDate: Date,
  providerEvents: Array<{ _id: string; start: Date; end: Date }> = [],
  currentAppointmentId?: string,
  timezone: string = DEFAULT_TZ
): { hasConflict: boolean; reason?: string } {
  const slotStart = dayjs(slotStartDate).tz(timezone);
  const slotEnd = dayjs(slotEndDate).tz(timezone);

  for (const event of providerEvents) {
    // Skip events from the current appointment being edited
    const eventAppointmentId = event._id.split('-')[0];
    if (currentAppointmentId && eventAppointmentId === String(currentAppointmentId)) {
      continue;
    }

    const eventStart = dayjs(event.start).tz(timezone);
    const eventEnd = dayjs(event.end).tz(timezone);

    // Check for overlap
    const hasOverlap = slotStart.isBefore(eventEnd) && slotEnd.isAfter(eventStart);
    
    if (hasOverlap) {
      return { 
        hasConflict: true, 
        reason: `Booked ${eventStart.format('h:mm A')} - ${eventEnd.format('h:mm A')}` 
      };
    }
  }

  return { hasConflict: false };
}

// Helper to check provider availability in schedule
function isProviderAvailableInSlot(
  providerSchedule: any,
  slotStartDate: Date,
  slotEndDate: Date,
  timezone: string = DEFAULT_TZ
): { available: boolean; reason?: string } {
  if (!providerSchedule || !providerSchedule.weekly) {
    return { available: false, reason: 'No schedule' };
  }

  const slotStart = dayjs(slotStartDate).tz(timezone);
  const slotEnd = dayjs(slotEndDate).tz(timezone);

  if (!slotStart.isSame(slotEnd, 'day')) {
    return { available: false, reason: 'Multi-day slot' };
  }

  const dayOfWeek = slotStart.day();
  const dayKeys = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
  const dayKey = dayKeys[dayOfWeek];
  
  const dayBlocks = providerSchedule.weekly[dayKey];

  if (!Array.isArray(dayBlocks) || dayBlocks.length === 0) {
    return { available: false, reason: 'Not working this day' };
  }

  const slotStartTime = slotStart.hour() * 60 + slotStart.minute();
  const slotEndTime = slotEnd.hour() * 60 + slotEnd.minute();

  for (const block of dayBlocks) {
    const [startHour, startMin] = block.start.split(':').map(Number);
    const [endHour, endMin] = block.end.split(':').map(Number);
    const blockStart = startHour * 60 + startMin;
    const blockEnd = endHour * 60 + endMin;

    if (slotStartTime >= blockStart && slotEndTime <= blockEnd) {
      return { available: true };
    }
  }

  return { available: false, reason: 'Outside working hours' };
}

const ProviderRowWithAvailability = memo<{
  provider: Provider;
  slotStartDate: string;
  slotStartTime: string;
  slotDurationMinutes: number;
  appointmentId?: string;
  onAdd: () => void;
}>(({ provider, slotStartDate, slotStartTime, slotDurationMinutes, appointmentId, onAdd }) => {
  const { data: providerSchedule } = useProviderSchedule(provider._id);
  
  // Calculate slot dates
  const { startDate, endDate } = useMemo(() => {
    try {
      const start = new Date(`${slotStartDate}T${slotStartTime}`);
      const end = new Date(start.getTime() + slotDurationMinutes * 60 * 1000);
      return { startDate: start, endDate: end };
    } catch {
      return { startDate: new Date(), endDate: new Date() };
    }
  }, [slotStartDate, slotStartTime, slotDurationMinutes]);

  // Calculate date range for query
  const dateRange = useMemo(() => {
    const start = dayjs(startDate).tz(DEFAULT_TZ).subtract(1, 'day');
    const end = dayjs(endDate).tz(DEFAULT_TZ).add(1, 'day');
    return {
      from: start.toISOString(),
      to: end.toISOString(),
    };
  }, [startDate, endDate]);

  // Fetch provider's existing appointments
  const { data: providerEvents = [] } = useProviderAppointments(provider._id, dateRange);

  const availabilityCheck = useMemo(() => {
    // Check schedule availability
    const scheduleCheck = isProviderAvailableInSlot(providerSchedule, startDate, endDate, DEFAULT_TZ);
    if (!scheduleCheck.available) {
      return { available: false, reason: scheduleCheck.reason };
    }

    // Check for appointment conflicts
    const conflictCheck = hasTimeConflict(startDate, endDate, providerEvents, appointmentId, DEFAULT_TZ);
    
    if (conflictCheck.hasConflict) {
      return { available: false, reason: conflictCheck.reason };
    }

    return { available: true };
  }, [providerSchedule, providerEvents, startDate, endDate, appointmentId]);

  const statusTag = useMemo(() => {
    if (availabilityCheck.available) {
      return { label: 'Available', color: 'green' };
    }
    return { label: availabilityCheck.reason || 'Unavailable', color: 'red' };
  }, [availabilityCheck]);

  const providerName = `${provider.firstName} ${provider.lastName}`;

  return (
    <HStack
      as="div"
      justify="space-between"
      px={2}
      py={2}
      borderRadius="md"
      _hover={{ bg: 'blackAlpha.50' }}
      cursor="pointer"
      onClick={onAdd}
    >
      <HStack>
        <Box w="8px" h="8px" borderRadius="full" bg={provider.color || 'gray.300'} />
        <Text fontSize="sm" fontWeight="medium" textTransform="capitalize">
          {providerName}
        </Text>
      </HStack>
      <Tag size="sm" colorScheme={statusTag.color}>
        {statusTag.label}
      </Tag>
    </HStack>
  );
});
ProviderRowWithAvailability.displayName = "ProviderRowWithAvailability";

// Status color mapping for slots (usado en TabPanels)
const SLOT_STATUS_COLOR: Record<string, string> = {
  confirmed: 'green',
  pending: 'yellow',
  nocontacted: 'gray',
  contacted: 'blue',
  declined: 'red',
  reschedule: 'purple',
  cancelled: 'red',
  unknown: 'gray',
  new: 'blue',
};

// -----------------------------
// Componente principal
// -----------------------------
export type PremiumAppointmentModalProps = {
  id: string;
  isOpen: boolean;
  onClose: () => void;
  initialSlotId?: string; // ID del slot a mostrar por defecto
};

const PremiumAppointmentModal: React.FC<PremiumAppointmentModalProps> = ({
  id,
  isOpen,
  onClose,
  initialSlotId,
}) => {
  const headerBg = useColorModeValue(
    "linear-gradient(135deg, rgba(0,0,0,0.02) 0%, rgba(0,0,0,0) 100%), linear-gradient(90deg, #7C3AED 0%, #06B6D4 100%)",
    "linear-gradient(135deg, rgba(255,255,255,0.06) 0%, rgba(255,255,255,0) 100%), linear-gradient(90deg, #7C3AED 0%, #06B6D4 100%)"
  );
  const sub = useColorModeValue("blackAlpha.700", "whiteAlpha.700");
  const border = useColorModeValue("blackAlpha.200", "whiteAlpha.300");
  
  // Color mode values used throughout the component
  const slotDateBg = useColorModeValue("gray.50", "gray.800");
  const slotDateBorder = useColorModeValue("gray.200", "gray.600");
  const slotDateTextColor = useColorModeValue("gray.600", "gray.300");
  const labelBoxBg = useColorModeValue("purple.50", "purple.900");
  const labelBoxTextColor = useColorModeValue("purple.700", "purple.200");
  const labelPreviewBg = useColorModeValue("white", "gray.700");
  const labelPreviewBorder = useColorModeValue("purple.200", "purple.700");
  const editorBoxBg = useColorModeValue("blue.50", "blue.900");
  const notesBg = useColorModeValue("blackAlpha.50", "whiteAlpha.100");

  const toast = useToast();
  const queryClient = useQueryClient();
  const { socket, connected } = useSocket();

  // Mutation para actualizar appointment
  const { mutate: updateAppointment, isPending: isUpdating } = useUpdateItems(
    "update-items",
    {
      invalidateKeys: [
        ["Appointment"],
        ["DraggableCards"],
        ["ContactAppointment"],
      ],
    }
  );

  // Modals state
  const {
    isOpen: isProviderOpen,
    onClose: onProviderClose,
  } = useDisclosure();
  
  const {
    isOpen: isRepOpen,
    onOpen: onRepOpen,
    onClose: onRepClose,
  } = useDisclosure();
  
  const {
    isOpen: isDeleteOpen,
    onOpen: onDeleteOpen,
    onClose: onDeleteClose,
  } = useDisclosure();
  
  const {
    isOpen: isLabelManagerOpen,
    onOpen: onLabelManagerOpen,
    onClose: onLabelManagerClose,
  } = useDisclosure();
  
  const [selectedProvider, setSelectedProvider] = useState<Provider | null>(null);
  const [selectedSlotForDelete, setSelectedSlotForDelete] = useState<AppointmentSlot | null>(null);
  const [showAllContacts, setShowAllContacts] = useState(false);
  const [showAllReviews, setShowAllReviews] = useState(false);
  const [isEditingAvailability, setIsEditingAvailability] = useState(false);
  const [editingAvailability, setEditingAvailability] = useState<SelectedDaysState | null>(null);
  const cancelRef = React.useRef<HTMLButtonElement>(null);

  // ðŸ‘‡ Modal index (solo gestiÃ³n open/close)
  // MantÃ©n el registro en el stack por si se requiere z-index entre modales, aunque no bloqueamos la visibilidad
  useModalIndex(isOpen, { id: "premium-appointment-modal" });
  const isTopOpen = isOpen;

  // --- Fetch con populate actualizado a tus refs ---
  const populateFields = [
    { path: "priority", select: "id description notes durationHours name color org_id" },
    { path: "treatment", select: "_id name duration icon minIcon color category active" },
    { path: "providers" },
    // âœ¨ NUEVO: populate de campos en cada slot
    { path: "selectedAppDates.treatment", select: "_id name duration icon minIcon color category active" },
    { path: "selectedAppDates.priority", select: "id description notes durationHours name color org_id" },
    { path: "selectedAppDates.providers", select: "_id firstName lastName email phone" },
    { path: "selectedDates.days.timeBlocks", select: "_id org_id blockNumber label short from to" },
    { path: "user", select: "auth0_id name email" },
    // Necesitamos los datos del representante para mostrar el telÃ©fono efectivo
    { path: "representative.appointment", select: "nameInput lastNameInput phoneInput phoneE164 emailLower sid proxyAddress" },
  ] as const;

  const limit = 25;
  const safeQuery = React.useMemo(
    () => (id && id.trim() ? { _id: id } : { _id: { $exists: false } }),
    [id]
  );

  const safeQuery2 = React.useMemo(
    () => (id && id.trim() ? { appointment: id } : { appointment: { $exists: false } }),
    [id]
  );

  const { data, isLoading, refetch } = useGetCollection<Appointment>(
    "Appointment",
    { mongoQuery: safeQuery, limit, populate: populateFields }
  );

  // ðŸ‘‰ Contact logs population: bring only minimal slot fields to reduce payload.
  // NOTE: Mongoose populate 'select' can't deep-filter array elements; we still project only needed keys.
  // For tighter backend filtering (single selectedAppDate), we'd need a custom endpoint or aggregation ($filter).
  const populateFieldsContacted = [
    { path: "user", select: "auth0_id name email" },
    { path: "appointment", select: "selectedAppDates._id selectedAppDates.startDate selectedAppDates.endDate selectedAppDates.proposed selectedAppDates.confirmation" },
    // selectedAppDate es un ObjectId a subdocumento embebido: no se puede hacer populate directo
  ] as const;

  const { data: contacted } = useGetCollection<ContactAppointment>(
    "ContactAppointment",
    { mongoQuery: safeQuery2, limit, populate: populateFieldsContacted }
  );

  // âœ¨ Fetch Google Review requests for this patient
  const { data: reviewRequests } = useGoogleReviewRequests(id);

  // Get appointment and org_id FIRST
  const appointment = data?.[0] ?? null;
  const orgId = appointment?.org_id;
  
  // Get shared labels (from Organizer topics)
  const { labels: orgLabels } = useAppointmentLabels();

  // Fetch all treatments and providers for editing slots (filtered by org_id)
  // Use useMemo to create stable query object
  const treatmentsQuery = React.useMemo(
    () => {
      const query = orgId 
        ? { org_id: orgId, $or: [{ active: true }, { active: { $exists: false } }] }
        : { _id: { $exists: false } };
      return query;
    },
    [orgId]
  );

  const providersQuery = React.useMemo(
    () => {
      const query = orgId ? { org_id: orgId } : { _id: { $exists: false } };
      return query;
    },
    [orgId]
  );


  // Enrich contact logs (memoized with centralized logic)
  const contactedSlim = useMemo<ContactAppointmentSlim[]>(() => {
    if (!contacted) return [];
    
    return (contacted as ContactAppointmentSlim[]).map((log) => {
      const populatedApp = log?.appointment as { selectedAppDates?: AppointmentSlot[] } | undefined;
      const list: AppointmentSlot[] = Array.isArray(populatedApp?.selectedAppDates)
        ? populatedApp.selectedAppDates
        : [];
      
      const matched = matchSlot(log, list);
      
      const slim: ContactAppointmentSlim = { ...log };
      if (matched) {
        slim.selectedAppDate = matched;
        if (populatedApp) {
          slim.appointment = { ...populatedApp, selectedAppDates: [matched] };
        }
      }
      return slim;
    });
  }, [contacted]);
  
  // Deduplicated and sorted slots (memoized)
  const dedupedSlots = useMemo(
    () => deduplicateAndSortSlots(appointment?.selectedAppDates ?? []),
    [appointment?.selectedAppDates]
  );
  
  const displaySlot = useMemo(
    () => pickDisplaySlot(dedupedSlots as any),
    [dedupedSlots]
  );
  
  // Calcular el Ã­ndice del tab inicial basado en initialSlotId
  const initialTabIndex = useMemo(() => {
    if (!initialSlotId || dedupedSlots.length === 0) {
      console.log('ðŸ” AppointmentModal: No initialSlotId or empty slots');
      return 0;
    }
    const index = dedupedSlots.findIndex(slot => String(slot?._id ?? '') === initialSlotId);
    console.log('ðŸ” AppointmentModal calculating tab index:', {
      initialSlotId,
      initialSlotIdType: typeof initialSlotId,
      dedupedSlotsCount: dedupedSlots.length,
      dedupedSlotIds: dedupedSlots.map(s => s._id),
      dedupedSlotIdsStrings: dedupedSlots.map(s => String(s?._id ?? '')),
      comparisonResults: dedupedSlots.map((s, i) => ({
        index: i,
        slotId: String(s?._id ?? ''),
        matches: String(s?._id ?? '') === initialSlotId,
        exactMatch: s?._id === initialSlotId,
      })),
      foundIndex: index,
      finalIndex: index >= 0 ? index : 0
    });
    return index >= 0 ? index : 0;
  }, [initialSlotId, dedupedSlots]);
  
  const cap = useCallback((s?: string) => 
    (s ?? "").toLocaleLowerCase().replace(/^\p{L}/u, c => c.toLocaleUpperCase()),
    []
  );
  
  const fullName = useMemo(() => {
    const name = cap(appointment?.nameInput);
    const last = cap(appointment?.lastNameInput);
    const v = `${name} ${last}`.trim();
    return v || "Unnamed";
  }, [appointment, cap]);

  // TelÃ©fono efectivo (mismo criterio que en DraggableCards)
  const hasRep = Boolean((appointment as any)?.representative?.appointment);
  const rep = hasRep && typeof (appointment as any)?.representative?.appointment === 'object'
    ? (appointment as any).representative.appointment as any
    : null;
  const phoneDisplay = useMemo(() => 
    rep
      ? formatAusPhoneNumber(rep.phoneInput || rep.phoneE164 || "")
      : formatAusPhoneNumber(appointment?.phoneInput || ""),
    [rep, appointment]
  );

  // ðŸ”„ Live refresh: ensure modal always shows the freshest appointment after server-side updates
  React.useEffect(() => {
    if (!socket || !connected || !id) return;
    // When a confirmation resolves, refetch this specific appointment + general lists
    const handleConfirm = (evt: any) => {
      // evt.conversationId matches appointment.sid (conversation) or we fallback to always refetch
      if (!appointment || evt?.conversationId === appointment.sid) {
        queryClient.invalidateQueries({ queryKey: ["Appointment"] });
        queryClient.refetchQueries({ queryKey: ["Appointment"] });
        queryClient.invalidateQueries({ queryKey: ["DraggableCards"] });
        queryClient.refetchQueries({ queryKey: ["DraggableCards"] });
      }
    };
    socket.on("confirmationResolved", handleConfirm);
    return () => {
      socket.off("confirmationResolved", handleConfirm);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [socket, connected, id, appointment?.sid]);

  // Helper to safely convert dates with validation
  const safeConvertDate = useCallback((date: Date | string | undefined): string | undefined => {
    if (!date) return undefined;
    try {
      const d = date instanceof Date ? date : new Date(date);
      if (isNaN(d.getTime())) return undefined;
      return d.toISOString();
    } catch {
      return undefined;
    }
  }, []);

  // Helper to format date for input[type="date"] (YYYY-MM-DD)
  const formatDateInput = useCallback((date: Date | string): string => {
    try {
      const d = new Date(date);
      if (isNaN(d.getTime())) return '';
      
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    } catch {
      return '';
    }
  }, []);

  // Helper to format time for input[type="time"] (HH:mm)
  const formatTimeInput = useCallback((date: Date | string): string => {
    try {
      const d = new Date(date);
      if (isNaN(d.getTime())) return '09:00';
      
      const hours = String(d.getHours()).padStart(2, '0');
      const minutes = String(d.getMinutes()).padStart(2, '0');
      return `${hours}:${minutes}`;
    } catch {
      return '09:00';
    }
  }, []);

  // Handler for slot changes using AppointmentSlotEditorModal
  const handleSlotChange = useCallback((slotGlobalIndex: number, updates: Partial<DateRange>) => {
    if (!appointment?._id || isUpdating) return;
    
    const currentSlots = appointment.selectedAppDates ?? [];
    if (slotGlobalIndex < 0 || slotGlobalIndex >= currentSlots.length) {
      toast({
        title: "Invalid slot index",
        status: "error",
        duration: 2000,
      });
      return;
    }

    const updatedSlots = currentSlots.map((slot, idx) => {
      if (idx !== slotGlobalIndex) return slot;

      // Deep clone to prevent mutations
      const updated: AppointmentSlot = {
        ...slot,
        // Preserve nested objects with deep clone
        proposed: slot.proposed ? { ...slot.proposed } : undefined,
        confirmation: slot.confirmation ? { ...slot.confirmation } : undefined,
      };

      // Update dates with validation
      if (updates.startDate !== undefined) {
        const converted = safeConvertDate(updates.startDate);
        if (converted) updated.startDate = converted;
      }
      
      if (updates.endDate !== undefined) {
        const converted = safeConvertDate(updates.endDate);
        if (converted) updated.endDate = converted;
      }
      
      // Update treatment (only store IDs, never populated objects)
      if (updates.treatment !== undefined) {
        (updated as any).treatment = updates.treatment ? String(updates.treatment) : undefined;
      }
      
      // Update priority (only store IDs)
      if (updates.priority !== undefined) {
        (updated as any).priority = updates.priority ? String(updates.priority) : undefined;
      }
      
      // Update providers (array of IDs with validation)
      if (updates.providers !== undefined) {
        (updated as any).providers = Array.isArray(updates.providers)
          ? updates.providers.filter(Boolean).map(String)
          : [];
      }
      
      // Update duration with validation
      if (updates.duration !== undefined) {
        const dur = Number(updates.duration);
        if (!isNaN(dur) && dur > 0) {
          (updated as any).duration = dur;
        }
      }
      
      // Update labels (array of IDs with validation)
      if (updates.labels !== undefined) {
        (updated as any).labels = Array.isArray(updates.labels)
          ? updates.labels.filter(Boolean).map(String)
          : [];
      }

      updated.updatedAt = new Date().toISOString();
      return updated;
    });

    // Validate changes were made
    if (JSON.stringify(updatedSlots) === JSON.stringify(currentSlots)) {
      return;
    }

    updateAppointment(
      [
        {
          table: "Appointment",
          id_field: "_id",
          id_value: appointment._id,
          data: {
            selectedAppDates: updatedSlots,
          },
        },
      ],
      {
        onSuccess: () => {
          toast({
            title: "Slot updated successfully",
            status: "success",
            duration: 2000,
          });
          refetch();
        },
        onError: (error) => {
          toast({
            title: "Failed to update slot",
            description: error instanceof Error ? error.message : String(error),
            status: "error",
            duration: 3000,
          });
        },
      }
    );
  }, [appointment, isUpdating, updateAppointment, toast, refetch, safeConvertDate]);

  const handleDeleteSlot = useCallback((slot: AppointmentSlot) => {
    setSelectedSlotForDelete(slot);
    onDeleteOpen();
  }, [onDeleteOpen]);

  const handleEditAvailability = useCallback(() => {
    if (!appointment?.selectedDates?.days) {
      setEditingAvailability({});
    } else {
      // Convertir selectedDates a formato SelectedDaysState
      const daysState: any = {};
      appointment.selectedDates.days.forEach((day: any) => {
        if (day.timeBlocks && day.timeBlocks.length > 0) {
          daysState[day.weekDay] = day.timeBlocksData || day.timeBlocks;
        }
      });
      setEditingAvailability(daysState as SelectedDaysState);
    }
    setIsEditingAvailability(true);
  }, [appointment]);

  const handleCancelAvailability = useCallback(() => {
    setIsEditingAvailability(false);
    setEditingAvailability(null);
  }, []);

  const handleSaveAvailability = useCallback((value: SelectedDatesValue) => {
    if (!appointment?._id || isUpdating) return;

    updateAppointment(
      [
        {
          table: "Appointment",
          id_field: "_id",
          id_value: appointment._id,
          data: {
            selectedDates: value,
          },
        },
      ],
      {
        onSuccess: () => {
          toast({
            title: "Availability updated successfully",
            status: "success",
            duration: 2000,
          });
          setIsEditingAvailability(false);
          setEditingAvailability(null);
          refetch();
        },
        onError: (error) => {
          toast({
            title: "Failed to update availability",
            description: String(error),
            status: "error",
            duration: 3000,
          });
        },
      }
    );
  }, [appointment, isUpdating, updateAppointment, toast, refetch]);

  const confirmDeleteSlot = useCallback(async () => {
    if (!selectedSlotForDelete || !appointment?._id || isUpdating) return;

    const selectedId = String(selectedSlotForDelete._id ?? '');
    
    // Filtrar el slot a eliminar usando mÃºltiples criterios para mayor seguridad
    const updatedSlots = (appointment.selectedAppDates ?? []).filter((slot) => {
      const slotId = String(slot._id ?? '');
      
      // Si no hay ID, usar comparaciÃ³n por fechas
      if (!slotId || !selectedId) {
        const slotStart = slot?.startDate || slot?.proposed?.startDate;
        const slotEnd = slot?.endDate || slot?.proposed?.endDate;
        const selectedStart = selectedSlotForDelete?.startDate || selectedSlotForDelete?.proposed?.startDate;
        const selectedEnd = selectedSlotForDelete?.endDate || selectedSlotForDelete?.proposed?.endDate;
        
        return !(
          slotStart && slotEnd && selectedStart && selectedEnd &&
          new Date(slotStart).getTime() === new Date(selectedStart).getTime() &&
          new Date(slotEnd).getTime() === new Date(selectedEnd).getTime()
        );
      }
      
      // ComparaciÃ³n por ID
      return slotId !== selectedId;
    });

    // Validar que no se elimine el Ãºltimo slot
    if (updatedSlots.length === 0) {
      toast({
        title: "Cannot delete last slot",
        description: "An appointment must have at least one slot",
        status: "warning",
        duration: 3000,
      });
      onDeleteClose();
      return;
    }

    // Validar que efectivamente se eliminÃ³ un slot
    if (updatedSlots.length === (appointment.selectedAppDates?.length ?? 0)) {
      toast({
        title: "Failed to delete slot",
        description: "Could not identify the slot to delete",
        status: "error",
        duration: 3000,
      });
      return;
    }

    updateAppointment(
      [
        {
          table: "Appointment",
          id_field: "_id",
          id_value: appointment._id,
          data: {
            selectedAppDates: updatedSlots,
          },
        },
      ],
      {
        onSuccess: () => {
          toast({
            title: "Slot deleted successfully",
            status: "success",
            duration: 2000,
          });
          setSelectedSlotForDelete(null);
          onDeleteClose();
          refetch();
        },
        onError: (error) => {
          toast({
            title: "Failed to delete slot",
            description: String(error),
            status: "error",
            duration: 3000,
          });
        },
      }
    );
  }, [selectedSlotForDelete, appointment, isUpdating, updateAppointment, toast, refetch, onDeleteClose]);

  return (
    <>
      {/* Main Modal - hidden when provider modal is open */}
      <Modal isOpen={isTopOpen && !isProviderOpen} onClose={onClose} size="6xl" closeOnOverlayClick={false}>
        <ModalOverlay backdropFilter="blur(6px)" />
        <ModalContent
          overflow="hidden"
          border="1px solid"
          borderColor={border}
          rounded="2xl"
        >
          {/* Header */}
          <Box
            bg={headerBg}
            color="white"
            px={6}
            py={6}
            borderLeftWidth={6}
            borderLeftStyle="solid"
            borderLeftColor={appointment?.color ?? "transparent"}
          >
            <HStack spacing={4} align="center" justify="space-between">
              <HStack spacing={4} align="center">
                <Avatar
                  name={appointment?.nameInput?.[0] || fullName}
                  {...enrichAvatarColor(appointment?.color)}
                  size="lg"
                  boxShadow="0 2px 8px rgba(0,0,0,0.15)"
                />
                <VStack align="start" spacing={1} flex={1}>
                  <HStack wrap="wrap" spacing={3} align="center">
                    <Text fontSize="xl" fontWeight="extrabold">
                      {fullName}
                    </Text>

                    {appointment?.unknown ? (
                      <Badge colorScheme="orange" rounded="full">
                        Unknown
                      </Badge>
                    ) : null}
                    {/* TelÃ©fono al lado del nombre (estilizado) */}
                    <Box
                      bg="whiteAlpha.200"
                      px={2}
                      py={1}
                      rounded="full"
                      border="1px solid"
                      borderColor="whiteAlpha.300"
                    >
                      <HStack spacing={2} align="center" color="white">
                        <PhoneIcon boxSize={3.5} />
                        {rep ? (
                          <HStack spacing={1} align="center">
                            <Box
                              as="button"
                              onClick={(e: React.MouseEvent) => {
                                e.stopPropagation();
                                onRepOpen();
                              }}
                              aria-label="Open representative"
                              _hover={{ opacity: 0.9 }}
                            >
                              <Box as={RiParentFill} color="purple.200" />
                            </Box>
                            <Text fontSize="sm" fontWeight="semibold">{phoneDisplay || 'â€”'}</Text>
                          </HStack>
                        ) : (
                          <Text fontSize="sm" fontWeight="semibold">{phoneDisplay || 'â€”'}</Text>
                        )}
                      </HStack>
                    </Box>
                  </HStack>
                </VStack>
              </HStack>
              {/* ðŸ”— Acceso rÃ¡pido al chat desde el header */}
              {appointment && (
                <ChatLauncher
                  item={appointment}
                  tooltip="Open chat"
                  buildContact={(i: Appointment) => {
                    // Always derive chat to representative if present; otherwise use patient
                    const repApp = (i as any)?.representative?.appointment && typeof (i as any)?.representative?.appointment === 'object'
                      ? ((i as any).representative.appointment as any)
                      : null;

                    if (repApp) {
                      const conversationId = repApp.sid || '';
                      const phone = repApp.phoneInput || repApp.phoneE164 || '';
                      const email = repApp.emailLower || '';
                      const author = `${repApp.nameInput || ''}`.trim();
                      return {
                        conversationId,
                        lastMessage: {
                          author,
                          body: '',
                          conversationId,
                          createdAt: new Date().toISOString(),
                          direction: 'outbound' as const,
                          media: [],
                          sid: 'temp-lastmessage',
                          status: 'delivered' as const,
                          updatedAt: new Date().toISOString(),
                        },
                        owner: {
                          email,
                          lastName: repApp.lastNameInput || '',
                          name: repApp.nameInput || '',
                          org_id: i.org_id || '',
                          phone,
                          color: (i as any)?.color || undefined,
                          unknown: false,
                          _id: repApp._id,
                          represented: true,
                        },
                      };
                    }

                    const conversationId = (i as any).sid || '';
                    const author = (i.nameInput || '').trim();
                    return {
                      conversationId,
                      lastMessage: {
                        author,
                        body: '',
                        conversationId,
                        createdAt: new Date().toISOString(),
                        direction: 'outbound' as const,
                        media: [],
                        sid: 'temp-lastmessage',
                        status: 'delivered' as const,
                        updatedAt: new Date().toISOString(),
                      },
                      owner: {
                        email: i.emailInput || '',
                        lastName: i.lastNameInput || '',
                        name: i.nameInput || '',
                        org_id: i.org_id || '',
                        phone: i.phoneInput || '',
                        color: (i as any)?.color || undefined,
                        unknown: !!i.unknown,
                        _id: i._id,
                        represented: false,
                      },
                    };
                  }}
                  modalInitial={{ appId: appointment._id }}
                  trigger={
                    <IconButton
                      aria-label="Open chat"
                      icon={<FaCommentSms />}
                      size="md"
                      variant="ghost"
                      color="white"
                      _hover={{ bg: "whiteAlpha.300" }}
                      _active={{ bg: "whiteAlpha.400" }}
                    />
                  }
                />
              )}
            </HStack>
          </Box>

          <ModalCloseButton top={3} right={3} color="white" />

          {/* Body */}
          <ModalBody px={6} py={5}>
            {isLoading && !appointment ? (
              <VStack align="stretch" spacing={4}>
                <Skeleton h="28px" />
                <Skeleton h="180px" />
                <Skeleton h="220px" />
              </VStack>
            ) : (
              <VStack align="stretch" spacing={5} w="full">
                {/* Selected Appointment Dates - Componente independiente */}
                <SectionCard
                  title={
                    <HStack>
                      <Icon as={FiCalendar} />
                      <Text>Selected Appointment Dates</Text>
                    </HStack>
                  }
                  
                >
                  <SelectedAppointmentDates
                    appointmentId={id}
                    initialSlotId={initialSlotId}
                    onSlotChange={handleSlotChange}
                    onSlotDelete={handleDeleteSlot}
                    isUpdating={isUpdating}
                  />
                </SectionCard>

                {/* SecciÃ³n de Notes */}
                          const startVal = slot?.startDate || slot?.proposed?.startDate;
                          const displayId = displaySlot ? String(displaySlot._id ?? "") : "";
                          const isLatest = String(slot?._id ?? '') === displayId;
                          
                          let dateLabel = "â€”";
                          if (startVal) {
                            try {
                              const start = new Date(startVal);
                              dateLabel = start.toLocaleDateString("en-AU", {
                                day: "numeric",
                                month: "short",
                                year: "numeric"
                              });
                            } catch {
                              dateLabel = `Slot ${idx + 1}`;
                            }
                          } else {
                            dateLabel = `Slot ${idx + 1}`;
                          }
                          
                          return (
                            <Tab key={slot?._id ?? idx} whiteSpace="nowrap">
                              <HStack spacing={2}>
                                <Text>{dateLabel}</Text>
                                {isLatest && (
                                  <Badge colorScheme="blue" variant="subtle" rounded="full" fontSize="xx-small">
                                    Latest
                                  </Badge>
                                )}
                              </HStack>
                            </Tab>
                          );
                        })}
                      </TabList>
                      
                      <TabPanels>
                        {dedupedSlots.map((slot, idx) => {
                          // Convertir slot a formato DateRange para AppointmentSlotEditorModal con validaciÃ³n robusta
                          const dateRange: DateRange = {
                            startDate: (() => {
                              try {
                                const d = slot?.startDate ? new Date(slot.startDate) : new Date();
                                return isNaN(d.getTime()) ? new Date() : d;
                              } catch {
                                return new Date();
                              }
                            })(),
                            endDate: (() => {
                              try {
                                const d = slot?.endDate ? new Date(slot.endDate) : new Date();
                                return isNaN(d.getTime()) ? new Date() : d;
                              } catch {
                                return new Date();
                              }
                            })(),
                            status: slot?.status,
                            slotId: slot?._id,
                            _id: slot?._id,
                            // Robust ID extraction from treatment (handles both populated objects and ID strings)
                            treatment: (() => {
                              const t = slot?.treatment;
                              if (!t) return undefined;
                              if (typeof t === 'string') return t;
                              if (typeof t === 'object' && t._id) return String(t._id);
                              return undefined;
                            })(),
                            // Robust ID extraction from priority
                            priority: (() => {
                              const p = slot?.priority;
                              if (!p) return undefined;
                              if (typeof p === 'string') return p;
                              if (typeof p === 'object' && p._id) return String(p._id);
                              return undefined;
                            })(),
                            // Safe provider ID extraction
                            providers: (slot?.providers ?? []).map(p => {
                              if (typeof p === 'string') return p;
                              if (typeof p === 'object' && p?._id) return String(p._id);
                              return null;
                            }).filter((p): p is string => p !== null),
                            // Robust duration calculation with multiple fallbacks
                            duration: (() => {
                              // 1. Priority: explicit duration on slot
                              const slotAny = slot as any;
                              if (slotAny?.duration && !isNaN(Number(slotAny.duration))) {
                                return Math.round(Number(slotAny.duration));
                              }
                              
                              // 2. Calculate from dates
                              if (slot?.startDate && slot?.endDate) {
                                try {
                                  const start = new Date(slot.startDate).getTime();
                                  const end = new Date(slot.endDate).getTime();
                                  if (!isNaN(start) && !isNaN(end) && end > start) {
                                    return Math.round((end - start) / (1000 * 60));
                                  }
                                } catch {}
                              }
                              
                              // 3. From treatment (only if populated)
                              const treatment = slot?.treatment;
                              if (treatment && typeof treatment === 'object' && treatment.duration) {
                                const dur = Number(treatment.duration);
                                if (!isNaN(dur)) return Math.round(dur);
                              }
                              
                              // 4. Safe default
                              return 60;
                            })(),
                            // Extract label IDs from slot (support both string[] and populated objects)
                            labels: (() => {
                              const slotAny = slot as any;
                              if (!slotAny?.labels || !Array.isArray(slotAny.labels)) return [];
                              return slotAny.labels.map((l: any) => {
                                if (typeof l === 'string') return l;
                                if (typeof l === 'object' && l?.id) return l.id;
                                if (typeof l === 'object' && l?._id) return String(l._id);
                                return null;
                              }).filter((id: any): id is string => typeof id === 'string' && id.length > 0);
                            })(),
                          };

                          return (
                            <TabPanel key={slot?._id ?? idx} px={0} pt={4}>
                              <VStack align="stretch" spacing={4}>
                                {/* Status badges */}
                                <HStack spacing={2} flexWrap="wrap">
                                  <Badge 
                                    rounded="full" 
                                    colorScheme={slot?.status ? (SLOT_STATUS_COLOR[slot.status.toLowerCase()] || 'gray') : 'gray'}
                                    fontSize="sm" 
                                    px={3} 
                                    py={1}
                                  >
                                    {slot?.status || 'Unknown'}
                                  </Badge>
                                  {slot?.rescheduleRequested && (
                                    <Badge colorScheme="orange" rounded="full" fontSize="sm" px={3} py={1}>
                                      Reschedule requested
                                    </Badge>
                                  )}
                                  {String(slot?._id ?? '') === String(displaySlot?._id ?? "") && (
                                    <Badge colorScheme="blue" variant="subtle" rounded="full" fontSize="sm" px={3} py={1}>
                                      Latest
                                    </Badge>
                                  )}
                                  <Tooltip label="Delete slot">
                                    <IconButton
                                      icon={<FiTrash2 />}
                                      size="sm"
                                      variant="ghost"
                                      colorScheme="red"
                                      aria-label="Delete slot"
                                      onClick={() => handleDeleteSlot(slot)}
                                      ml="auto"
                                    />
                                  </Tooltip>
                                </HStack>

                                {/* Date/Time Controls - Editable */}
                                <Box
                                  bg={slotDateBg}
                                  p={4}
                                  rounded="lg"
                                  mb={4}
                                  borderWidth="1px"
                                  borderColor={slotDateBorder}
                                >
                                  <VStack align="stretch" spacing={3}>
                                    <HStack>
                                      <Icon as={FiCalendar} color="blue.500" />
                                      <Text fontSize="sm" fontWeight="bold" color="blue.600">
                                        Appointment Date & Time
                                      </Text>
                                    </HStack>

                                    {/* Start Date & Time */}
                                    <VStack align="stretch" spacing={2}>
                                      <Text fontSize="xs" fontWeight="semibold" textTransform="uppercase" color={slotDateTextColor}>
                                        ðŸ“… Start Date & Time
                                      </Text>
                                      <HStack spacing={2}>
                                        <Input
                                          type="date"
                                          value={formatDateInput(dateRange.startDate)}
                                          onChange={(e) => {
                                            if (!e.target.value) return;
                                            
                                            const [year, month, day] = e.target.value.split('-').map(Number);
                                            if (isNaN(year) || isNaN(month) || isNaN(day)) return;
                                            
                                            try {
                                              const currentStart = new Date(dateRange.startDate);
                                              const newStart = new Date(
                                                year, 
                                                month - 1, 
                                                day, 
                                                currentStart.getHours(), 
                                                currentStart.getMinutes()
                                              );
                                              
                                              if (isNaN(newStart.getTime())) return;
                                              
                                              const duration = dateRange.duration || 60;
                                              const newEnd = new Date(newStart.getTime() + duration * 60 * 1000);
                                              
                                              handleSlotChange(idx, {
                                                startDate: newStart,
                                                endDate: newEnd,
                                              });
                                            } catch (error) {
                                              // Error updating date
                                            }
                                          }}
                                          size="md"
                                          flex={2}
                                          disabled={isUpdating}
                                        />
                                        <Input
                                          type="time"
                                          value={formatTimeInput(dateRange.startDate)}
                                          onChange={(e) => {
                                            if (!e.target.value) return;
                                            
                                            const [hours, minutes] = e.target.value.split(':').map(Number);
                                            if (isNaN(hours) || isNaN(minutes)) return;
                                            
                                            try {
                                              const currentStart = new Date(dateRange.startDate);
                                              const newStart = new Date(
                                                currentStart.getFullYear(), 
                                                currentStart.getMonth(), 
                                                currentStart.getDate(), 
                                                hours, 
                                                minutes
                                              );
                                              
                                              if (isNaN(newStart.getTime())) return;
                                              
                                              const duration = dateRange.duration || 60;
                                              const newEnd = new Date(newStart.getTime() + duration * 60 * 1000);
                                              
                                              handleSlotChange(idx, {
                                                startDate: newStart,
                                                endDate: newEnd,
                                              });
                                            } catch (error) {
                                              // Error updating time
                                            }
                                          }}
                                          size="md"
                                          flex={1}
                                          disabled={isUpdating}
                                        />
                                      </HStack>
                                    </VStack>
                                  </VStack>
                                </Box>

                                {/* Labels Section */}
                                <Box
                                  bg={labelBoxBg}
                                  p={4}
                                  rounded="lg"
                                >
                                  <HStack justify="space-between" mb={3}>
                                    <Text fontSize="sm" fontWeight="bold" color={labelBoxTextColor}>
                                      ðŸ·ï¸ Labels
                                    </Text>
                                    <Button 
                                      size="xs" 
                                      onClick={onLabelManagerOpen}
                                      colorScheme="purple"
                                      variant="outline"
                                    >
                                      Manage Labels
                                    </Button>
                                  </HStack>
                                  
                                  <VStack align="stretch" spacing={3}>
                                    <AppointmentLabelAssigner
                                      orgLabels={orgLabels}
                                      value={dateRange.labels || []}
                                      onChange={(labelIds) => {
                                        console.log('ðŸ·ï¸ Labels changed:', { slotIndex: idx, labelIds, orgLabels });
                                        handleSlotChange(idx, { labels: labelIds });
                                      }}
                                      onCreateRequested={onLabelManagerOpen}
                                    />
                                    
                                    {/* Preview of assigned labels */}
                                    {(dateRange.labels || []).length > 0 && (
                                      <Box
                                        p={3}
                                        bg={labelPreviewBg}
                                        rounded="md"
                                        borderWidth="1px"
                                        borderColor={labelPreviewBorder}
                                      >
                                        <Text fontSize="xs" color="gray.500" mb={2} fontWeight="semibold">
                                          Assigned labels:
                                        </Text>
                                        <Wrap spacing={2}>
                                          {(dateRange.labels || []).map(labelId => {
                                            const label = orgLabels.find(l => l.id === labelId);
                                            return label ? (
                                              <WrapItem key={labelId}>
                                                <LabelChip label={label} withText size="sm" />
                                              </WrapItem>
                                            ) : null;
                                          })}
                                        </Wrap>
                                      </Box>
                                    )}
                                  </VStack>
                                </Box>

                                {/* AppointmentSlotEditorModal integration */}
                                <Box
                                  bg={editorBoxBg}
                                  p={4}
                                  rounded="lg"
                                >
                                  <AppointmentSlotEditorModal
                                    mode="EDITION"
                                    tz="Australia/Sydney"
                                    selectedAppDates={[dateRange]}
                                    onSlotChange={(_slotIndex, updates) => {
                                      // _slotIndex serÃ¡ siempre 0 porque solo pasamos un slot
                                      handleSlotChange(idx, updates);
                                    }}
                                    appointmentId={appointment?._id}
                                    formBusy={isUpdating}
                                    onPendingAssignmentsChange={() => {}}
                                  />
                                </Box>
                              </VStack>
                            </TabPanel>
                          );
                        })}
                      </TabPanels>
                    </Tabs>
                  )}
                </SectionCard>

                {/* SecciÃ³n de Notes */}
                <SimpleGrid columns={{ base: 1, md: 2 }} spacing={5}>
                  <VStack align="stretch" spacing={5}>
                  

                  <SectionCard
                    title={
                      <HStack>
                        <Icon as={FiInfo} />
                        <Text>Notes</Text>
                      </HStack>
                    }
                  >
                    <VStack align="stretch" spacing={3}>
                      <Box
                        bg={notesBg}
                        p={3}
                        rounded="lg"
                      >
                        <Text fontSize="xs" color={sub} mb={1}>
                          Note
                        </Text>
                        <Text>{appointment?.note || "â€”"}</Text>
                      </Box>
                    </VStack>
                  </SectionCard>

                  <SectionCard
                    title={
                      <HStack>
                        <Icon as={FiInfo} />
                        <Text>Contact History</Text>
                      </HStack>
                    }
                    right={(() => {
                      const list = (contactedSlim ?? []) as any[];
                      const total = list.length;
                      const confirmed = list.filter((l) => statusKey((l as any).status) === "confirmed").length;
                      const declined = list.filter((l) => {
                        const sk = statusKey((l as any).status);
                        return sk === "rejected" || sk === "declined";
                      }).length;
                      const pending = list.filter((l) => statusKey((l as any).status) === "pending").length;
                      return (
                        <HStack spacing={2}>
                          <Badge rounded="full" colorScheme="blue">{total} attempts</Badge>
                          <Badge rounded="full" colorScheme="green">{confirmed} confirmed</Badge>
                          <Badge rounded="full" colorScheme="red">{declined} declined</Badge>
                          <Badge rounded="full" colorScheme="purple">{pending} pending</Badge>
                        </HStack>
                      );
                    })()}
                  >
                    {contactedSlim?.length === 0 ? (
                      <Text>â€”</Text>
                    ) : (
                      <VStack align="stretch" spacing={3}>
                        {contactedSlim?.slice(0, showAllContacts ? undefined : 1).map((log, idx) => (
                          <HStack
                            key={log._id ?? idx}
                            align="flex-start"
                            border="1px solid"
                            borderColor={border}
                            rounded="lg"
                            p={2}
                            justify="space-between"
                          >
                            <VStack align="start" spacing={1} flex={1}>
                              <HStack spacing={2}>
                                {(() => {
                                  const status = (log as any).status as string | undefined;
                                  const sk = statusKey(status);
                                  const isConfirmed = sk === "confirmed";
                                  const isPending = sk === "pending";
                                  const isRejected = sk === "rejected" || sk === "declined";
                                  const bg = isConfirmed
                                    ? "green.100"
                                    : isPending
                                      ? "purple.100"
                                      : isRejected
                                        ? "red.100"
                                        : "gray.100";
                                  const color = isConfirmed
                                    ? "green.800"
                                    : isPending
                                      ? "purple.800"
                                      : isRejected
                                        ? "red.800"
                                        : "gray.800";
                                  return (
                                    <Badge rounded="xl" px={2} py={1} bg={bg} color={color} fontSize="xs" fontWeight="bold" textTransform="uppercase">
                                      {capStatus(status)}
                                    </Badge>
                                  );
                                })()}
                              </HStack>
                              <HStack spacing={4} align="flex-start" flexWrap="wrap">
                                <LabeledRow
                                  icon={CiUser}
                                  label="User"
                                  value={
                                    ((log as any).user?.name || "")
                                      .trim()
                                      .split(" ")[0] ||
                                    (log as any).user?.email ||
                                    (log as any).user?.auth0_id
                                  }
                                />
                                <LabeledRow
                                  icon={GrContact}
                                  label="Contacted"
                                  value={fmtDateTime((log as any).sentAt || (log as any).createdAt)}
                                />
                                <LabeledRow
                                  icon={FiClock}
                                  label="Responded"
                                  value={
                                    (log as any).status && statusKey((log as any).status) !== "pending"
                                      ? fmtDateTime((log as any).respondedAt || (log as any).updatedAt)
                                      : "â€”"
                                  }
                                />
                                {(() => {
                                  // Resolver slot usando primero la version poblada dentro del propio log (appointment.selectedAppDates)
                                  const populatedApp = (log as any).appointment as any | undefined;
                                  const localList = Array.isArray(populatedApp?.selectedAppDates) ? populatedApp.selectedAppDates : [];
                                  const globalList = (appointment?.selectedAppDates ?? []) as any[];
                                  const list = localList.length ? localList : globalList;

                                  // selectedAppDate puede venir poblado (objeto) o como id (string)
                                  const rawSel = (log as any).selectedAppDate as string | AppointmentSlot | undefined;
                                  const selId = typeof rawSel === 'string' ? rawSel : '';
                                  let slot: AppointmentSlot | null = null;
                                  let linkSource: string = ""; // debug metadata

                                  // Preferimos el objeto ya poblado dentro de selectedAppDate
                                  if (rawSel && typeof rawSel === 'object') {
                                    slot = rawSel as AppointmentSlot;
                                    linkSource = '';
                                  }
                                  if (selId) {
                                    if (!slot) {
                                      slot = (list as AppointmentSlot[]).find((s: AppointmentSlot) => String(s?._id) === selId) || null;
                                      if (slot) linkSource = "selectedAppDate";
                                    }
                                  }
                                  if (!slot) {
                                    const askSid = (log as any).askMessageSid ? String((log as any).askMessageSid) : "";
                                    if (askSid) {
                                      slot = (list as AppointmentSlot[]).find((sd: AppointmentSlot) => String(sd?.confirmation?.askMessageSid || "") === askSid) || null;
                                      if (slot) linkSource = "askMessageSid";
                                    }
                                  }
                                  if (!slot) {
                                    const s = (log as any).startDate ? new Date((log as any).startDate) : null;
                                    const e = (log as any).endDate ? new Date((log as any).endDate) : null;
                                    const st = s && !isNaN(s.getTime()) ? s.getTime() : NaN;
                                    const et = e && !isNaN(e.getTime()) ? e.getTime() : NaN;
                                    if (!Number.isNaN(st) && !Number.isNaN(et)) {
                                      slot = (list as AppointmentSlot[]).find((sd: AppointmentSlot) => {
                                        const t1 = sd?.startDate ? new Date(sd.startDate as any).getTime() : NaN;
                                        const t2 = sd?.endDate ? new Date(sd.endDate as any).getTime() : NaN;
                                        const p1 = sd?.proposed?.startDate ? new Date(sd.proposed.startDate as any).getTime() : NaN;
                                        const p2 = sd?.proposed?.endDate ? new Date(sd.proposed.endDate as any).getTime() : NaN;
                                        return (t1 === st && t2 === et) || (p1 === st && p2 === et);
                                      }) || null;
                                      if (slot) linkSource = "dates";
                                    }
                                  }

                                  let proposedStr: string | null = null;
                                  let currentStr: string | null = null;

                                  // Proposed priority: use persisted log fields first, then fallback to slot
                                  if ((log as any).proposedStartDate && (log as any).proposedEndDate) {
                                    const logProposedStart = new Date((log as any).proposedStartDate);
                                    const logProposedEnd = new Date((log as any).proposedEndDate);
                                    if (!isNaN(logProposedStart.getTime()) && !isNaN(logProposedEnd.getTime())) {
                                      proposedStr = formatDateWS({ startDate: logProposedStart, endDate: logProposedEnd });
                                    }
                                  } else if (slot?.proposed?.startDate && slot?.proposed?.endDate) {
                                    proposedStr = formatDateWS({
                                      startDate: new Date(slot.proposed.startDate),
                                      endDate: new Date(slot.proposed.endDate)
                                    });
                                  } else if (slot?.proposed && slot?.startDate && slot?.endDate) {
                                    // proposed object exists but missing explicit proposed dates: treat slot dates as proposed
                                    proposedStr = formatDateWS({
                                      startDate: new Date(slot.startDate),
                                      endDate: new Date(slot.endDate)
                                    });
                                  }

                                  // Current always from actual slot top-level
                                  if (slot?.startDate && slot?.endDate) {
                                    currentStr = formatDateWS({
                                      startDate: new Date(slot.startDate),
                                      endDate: new Date(slot.endDate)
                                    });
                                  } else {
                                    const s = (log as any).startDate ? new Date((log as any).startDate) : null;
                                    const e = (log as any).endDate ? new Date((log as any).endDate) : null;
                                    if (s && e && !isNaN(s.getTime()) && !isNaN(e.getTime())) {
                                      currentStr = formatDateWS({ startDate: s as Date, endDate: e as Date });
                                    }
                                  }

                                  return (
                                    <>
                                      <LabeledRow icon={FiClock} label="Proposed" value={proposedStr ?? "â€”"} />
                                      <LabeledRow icon={FiClock} label="Current" value={currentStr ?? "â€”"} />
                                      {/* Optional debug badge showing link source (remove in prod) */}
                                      {process.env.NODE_ENV === 'development' && linkSource && (
                                        <Badge colorScheme="blue" rounded="full">{linkSource}</Badge>
                                      )}
                                    </>
                                  );
                                })()}
                              </HStack>
                            </VStack>
                          </HStack>
                        ))}
                        {contactedSlim && contactedSlim.length > 1 && (
                          <Button
                            size="sm"
                            variant="ghost"
                            colorScheme="blue"
                            onClick={() => setShowAllContacts(!showAllContacts)}
                            w="full"
                          >
                            {showAllContacts ? 'Show less' : `Show ${contactedSlim.length - 1} more`}
                          </Button>
                        )}
                      </VStack>
                    )}
                  </SectionCard>
                  </VStack>

                  {/* Columna derecha - Patient Availability & Google Reviews */}
                  <VStack align="stretch" spacing={5}>
                    {/* Patient Availability */}
                    <SectionCard 
                      title={
                        <HStack>
                          <Icon as={FiCalendar} />
                          <Text>Patient Availability</Text>
                        </HStack>
                      }
                      right={
                        !isEditingAvailability && (
                          <Button
                            size="sm"
                            leftIcon={<Icon as={FiEdit2} />}
                            colorScheme="blue"
                            variant="ghost"
                            onClick={handleEditAvailability}
                            isDisabled={isUpdating}
                          >
                            Edit
                          </Button>
                        )
                      }
                    >
                      {isEditingAvailability && editingAvailability !== null ? (
                        <VStack align="stretch" spacing={4}>
                          <AvailabilityDates2
                            value={editingAvailability}
                            onChange={(value: SelectedDatesValue) => {
                              // El componente AvailabilityDates2 ya maneja internamente la actualizaciÃ³n
                              // Solo necesitamos guardar el valor completo que nos llega
                              const daysState: any = {};
                              value.days.forEach((day: any) => {
                                // value.days ya contiene los objetos completos de TimeBlock desde AvailabilityDates2
                                if (day.timeBlocks && day.timeBlocks.length > 0) {
                                  daysState[day.weekDay] = day.timeBlocks;
                                }
                              });
                              setEditingAvailability(daysState as SelectedDaysState);
                            }}
                            baseStartDate={appointment?.selectedDates?.startDate ? new Date(appointment.selectedDates.startDate) : undefined}
                            initialDuration={appointment?.selectedDates?.startDate && appointment?.selectedDates?.endDate ? 
                              Math.ceil((new Date(appointment.selectedDates.endDate).getTime() - new Date(appointment.selectedDates.startDate).getTime()) / (1000 * 60 * 60 * 24)) as 7 | 14 | 30
                              : 7
                            }
                            showSummary
                            showDurationControl
                            allowDurationChange
                          />
                          <HStack spacing={2} justify="flex-end">
                            <Button size="sm" variant="ghost" onClick={handleCancelAvailability}>
                              Cancel
                            </Button>
                            <Button 
                              size="sm" 
                              colorScheme="blue" 
                              leftIcon={<Icon as={FiCalendar} />} 
                              onClick={() => {
                                if (editingAvailability) {
                                  const days: any = Object.entries(editingAvailability).map(([weekDay, timeBlocks]) => ({
                                    weekDay,
                                    timeBlocks: (timeBlocks ?? []).map((b: any) => ({ _id: b._id ?? "" })),
                                  }));
                                  
                                  const startDate = appointment?.selectedDates?.startDate ? new Date(appointment.selectedDates.startDate) : new Date();
                                  const duration = appointment?.selectedDates?.startDate && appointment?.selectedDates?.endDate ? 
                                    Math.ceil((new Date(appointment.selectedDates.endDate).getTime() - new Date(appointment.selectedDates.startDate).getTime()) / (1000 * 60 * 60 * 24))
                                    : 7;
                                  const endDate = new Date(startDate);
                                  endDate.setDate(endDate.getDate() + duration);
                                  
                                  handleSaveAvailability({
                                    startDate,
                                    endDate,
                                    days,
                                  });
                                }
                              }}
                              isLoading={isUpdating}
                            >
                              Save Changes
                            </Button>
                          </HStack>
                        </VStack>
                      ) : (
                        <AvailabilityDates2
                          value={(() => {
                            if (!appointment?.selectedDates?.days) return {};
                            const daysState: any = {};
                            appointment.selectedDates.days.forEach((day: any) => {
                              if (day.timeBlocks && day.timeBlocks.length > 0) {
                                daysState[day.weekDay] = day.timeBlocksData || day.timeBlocks;
                              }
                            });
                            return daysState as SelectedDaysState;
                          })()}
                          onChange={() => {}}
                          baseStartDate={appointment?.selectedDates?.startDate ? new Date(appointment.selectedDates.startDate) : undefined}
                          readOnly
                          showSummary
                        />
                      )}
                    </SectionCard>

                    <SectionCard
                    title={
                      <HStack>
                        <Icon as={FaStar} />
                        <Text>Google Reviews</Text>
                      </HStack>
                    }
                    right={(() => {
                      const list = reviewRequests ?? [];
                      const total = list.length;
                      const sent = list.filter((r: any) => r.status === 'sent' || r.status === 'delivered').length;
                      const clicked = list.filter((r: any) => r.status === 'clicked').length;
                      const reviewed = list.filter((r: any) => r.status === 'reviewed').length;
                      const failed = list.filter((r: any) => r.status === 'failed').length;
                      return (
                        <HStack spacing={2}>
                          <Badge rounded="full" colorScheme="blue">{total} requests</Badge>
                          {sent > 0 && <Badge rounded="full" colorScheme="green">{sent} sent</Badge>}
                          {clicked > 0 && <Badge rounded="full" colorScheme="purple">{clicked} clicked</Badge>}
                          {reviewed > 0 && <Badge rounded="full" colorScheme="yellow">{reviewed} reviewed</Badge>}
                          {failed > 0 && <Badge rounded="full" colorScheme="red">{failed} failed</Badge>}
                        </HStack>
                      );
                    })()}
                  >
                    {!reviewRequests || reviewRequests.length === 0 ? (
                      <Text>No review requests sent yet</Text>
                    ) : (
                      <VStack align="stretch" spacing={3}>
                        {reviewRequests.slice(0, showAllReviews ? undefined : 1).map((request: any, idx: number) => {
                          const statusColorMap: Record<string, string> = {
                            pending: 'gray',
                            sent: 'blue',
                            delivered: 'green',
                            clicked: 'purple',
                            reviewed: 'yellow',
                            failed: 'red',
                          };
                          const statusColor = statusColorMap[request.status] ?? 'gray';
                          
                          return (
                            <HStack
                              key={request._id ?? idx}
                              align="flex-start"
                              border="1px solid"
                              borderColor={border}
                              rounded="lg"
                              p={3}
                              justify="space-between"
                            >
                              <VStack align="start" spacing={2} flex={1}>
                                <HStack spacing={2} flexWrap="wrap">
                                  <Badge rounded="xl" px={2} py={1} colorScheme={statusColor} fontSize="xs" fontWeight="bold" textTransform="uppercase">
                                    {request.status}
                                  </Badge>
                                  {request.reviewRating && (
                                    <Badge rounded="xl" px={2} py={1} colorScheme="yellow" fontSize="xs">
                                      {request.reviewRating}â˜…
                                    </Badge>
                                  )}
                                </HStack>
                                
                                <SimpleGrid columns={{ base: 1, md: 2 }} spacing={3} w="full">
                                  <LabeledRow
                                    icon={FiClock}
                                    label="Requested"
                                    value={request.requestedAt ? format(new Date(request.requestedAt), 'MMM dd, yyyy HH:mm') : 'â€”'}
                                  />
                                  
                                  {request.sentAt && (
                                    <LabeledRow
                                      icon={FiClock}
                                      label="Sent"
                                      value={format(new Date(request.sentAt), 'MMM dd, yyyy HH:mm')}
                                    />
                                  )}
                                  
                                  {request.clickedAt && (
                                    <LabeledRow
                                      icon={FiClock}
                                      label="Clicked"
                                      value={format(new Date(request.clickedAt), 'MMM dd, yyyy HH:mm')}
                                    />
                                  )}
                                  
                                  {request.reviewedAt && (
                                    <LabeledRow
                                      icon={FaStar}
                                      label="Reviewed"
                                      value={format(new Date(request.reviewedAt), 'MMM dd, yyyy HH:mm')}
                                    />
                                  )}
                                </SimpleGrid>

                                {request.errorMessage && (
                                  <Box
                                    bg="red.50"
                                    border="1px solid"
                                    borderColor="red.200"
                                    rounded="md"
                                    p={2}
                                    w="full"
                                  >
                                    <Text fontSize="xs" color="red.700">
                                      Error: {request.errorMessage}
                                    </Text>
                                  </Box>
                                )}
                              </VStack>
                            </HStack>
                          );
                        })}
                        {reviewRequests && reviewRequests.length > 1 && (
                          <Button
                            size="sm"
                            variant="ghost"
                            colorScheme="blue"
                            onClick={() => setShowAllReviews(!showAllReviews)}
                            w="full"
                          >
                            {showAllReviews ? 'Show less' : `Show ${reviewRequests.length - 1} more`}
                          </Button>
                        )}
                      </VStack>
                    )}
                  </SectionCard>
                  </VStack>
                </SimpleGrid>
              </VStack>
            )}
          </ModalBody>

          {/* Footer */}
          <ModalFooter>
            <HStack w="full" justify="space-between">
              <HStack color={sub}>
                <FiInfo />
              </HStack>
              <HStack>
                <Button variant="ghost" onClick={onClose}>
                  Close
                </Button>
              </HStack>
            </HStack>
          </ModalFooter>
        </ModalContent>
      </Modal>

      {/* â€” Modal del Provider en lazy load â€” */}
      {selectedProvider && (
        <Suspense
          fallback={
            <Modal isOpen={isProviderOpen} onClose={() => { }} isCentered>
              <ModalOverlay />
              <ModalContent>
                <ModalBody p={6}>
                  <VStack align="stretch" spacing={3}>
                    <Skeleton h="24px" />
                    <Skeleton h="18px" />
                    <Skeleton h="240px" />
                  </VStack>
                </ModalBody>
              </ModalContent>
            </Modal>
          }
        >
          <ProviderSummaryModalLazy
            isOpen={isProviderOpen}
            onClose={() => {
              onProviderClose();
              setSelectedProvider(null);
              // ðŸ‘‡ Si quieres que al cerrar Provider se reabra el Appointment,
              //     no toques nada: al quedar isProviderOpen=false, este modal vuelve a abrirse
              //     automÃ¡ticamente por la condiciÃ³n (isTopOpen && !isProviderOpen).
            }}
            provider={selectedProvider}
          />
        </Suspense>
      )}

      {/* â€” Modal del Tutor (representante) en lazy load â€” */}
      {rep && (
        <Suspense
          fallback={
            <Modal isOpen={isRepOpen} onClose={() => { }} isCentered>
              <ModalOverlay />
              <ModalContent>
                <ModalBody p={6}>
                  <VStack align="stretch" spacing={3}>
                    <Skeleton h="24px" />
                    <Skeleton h="18px" />
                    <Skeleton h="240px" />
                  </VStack>
                </ModalBody>
              </ModalContent>
            </Modal>
          }
        >
          <AppointmentModalLazy id={String(rep._id || '')} isOpen={isRepOpen} onClose={onRepClose} />
        </Suspense>
      )}
      
      {/* Delete Confirmation Dialog */}
      <AlertDialog
        isOpen={isDeleteOpen}
        leastDestructiveRef={cancelRef}
        onClose={onDeleteClose}
      >
        <AlertDialogOverlay>
          <AlertDialogContent>
            <AlertDialogHeader fontSize="lg" fontWeight="bold">
              Delete Appointment Slot
            </AlertDialogHeader>
            
            <AlertDialogBody>
              Are you sure you want to delete this slot? This action cannot be undone.
            </AlertDialogBody>
            
            <AlertDialogFooter>
              <Button ref={cancelRef} onClick={onDeleteClose}>
                Cancel
              </Button>
              <Button colorScheme="red" onClick={confirmDeleteSlot} ml={3}>
                Delete
              </Button>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialogOverlay>
      </AlertDialog>

      {/* Label Manager Drawer - Shared labels between Organizer and Appointments */}
      <AppointmentLabelManager
        isOpen={isLabelManagerOpen}
        onClose={onLabelManagerClose}
      />
    </>
  );
};

export default memo(PremiumAppointmentModal);
